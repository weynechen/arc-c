/**
 * @file builtin_tools.c
 * @brief Built-in Tools Implementation
 *
 * This file implements the actual tool functions declared with AC_TOOL_META.
 * The wrapper functions and registration table are generated by MOC.
 */

#include "builtin_tools.h"
#include <agentc/sandbox.h>
#include <cJSON.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <sys/stat.h>
#include <dirent.h>
#include <unistd.h>
#include <sys/wait.h>

/*============================================================================
 * Static Configuration
 *============================================================================*/

static int g_safe_mode = 0;
static ac_sandbox_t *g_sandbox = NULL;

void builtin_tools_set_safe_mode(int enabled) {
    g_safe_mode = enabled;
}

void builtin_tools_set_sandbox(struct ac_sandbox *sandbox) {
    g_sandbox = sandbox;
}

struct ac_sandbox *builtin_tools_get_sandbox(void) {
    return g_sandbox;
}

/*============================================================================
 * Internal Helpers
 *============================================================================*/

/* Buffer for returning static strings from tools */
static char g_result_buffer[65536];

/* Build JSON response and store in buffer */
static const char* json_result(cJSON* json) {
    if (!json) {
        return "{\"error\": \"Failed to create response\"}";
    }
    
    char* str = cJSON_PrintUnformatted(json);
    cJSON_Delete(json);
    
    if (!str) {
        return "{\"error\": \"Failed to serialize response\"}";
    }
    
    /* Copy to static buffer for return */
    size_t len = strlen(str);
    if (len >= sizeof(g_result_buffer)) {
        len = sizeof(g_result_buffer) - 1;
    }
    memcpy(g_result_buffer, str, len);
    g_result_buffer[len] = '\0';
    
    free(str);
    return g_result_buffer;
}

static const char* json_error(const char* msg) {
    cJSON* json = cJSON_CreateObject();
    if (json) {
        cJSON_AddStringToObject(json, "error", msg);
    }
    return json_result(json);
}

/* Check if command is dangerous */
static int is_dangerous_command(const char* cmd) {
    const char* dangerous[] = {
        "rm -rf", "rm -fr", "sudo", "chmod 777", "chmod -R 777",
        "> /dev/", "mkfs", "dd if=", ":(){ :|:& };:",
        "mv /* ", "mv / ", NULL
    };
    
    for (int i = 0; dangerous[i] != NULL; i++) {
        if (strstr(cmd, dangerous[i]) != NULL) {
            return 1;
        }
    }
    return 0;
}

/*============================================================================
 * Tool: shell_execute
 *============================================================================*/

const char* shell_execute(const char* command) {
    if (!command || strlen(command) == 0) {
        return json_error("command parameter is required");
    }
    
    char* result = NULL;
    int exit_code = 0;
    
    /* If sandbox is configured, use sandboxed execution */
    if (g_sandbox) {
        /* Allocate result buffer */
        size_t result_cap = 65536;
        result = malloc(result_cap);
        if (!result) {
            return json_error("Memory allocation failed");
        }
        result[0] = '\0';
        
        /* Execute in sandboxed subprocess */
        agentc_err_t err = ac_sandbox_exec(g_sandbox, command, result, result_cap, &exit_code);
        
        if (err == AGENTC_ERR_INVALID_ARG) {
            /* Command was blocked by sandbox */
            cJSON* json = cJSON_CreateObject();
            cJSON_AddStringToObject(json, "error", "Command blocked by sandbox");
            cJSON_AddStringToObject(json, "command", command);
            cJSON_AddStringToObject(json, "reason", ac_sandbox_denial_reason());
            cJSON_AddStringToObject(json, "ai_hint", 
                "The sandbox policy prevents executing this command. "
                "The command may contain dangerous patterns or access restricted resources. "
                "Consider using a safer alternative or check the workspace configuration.");
            free(result);
            return json_result(json);
        } else if (err == AGENTC_ERR_TIMEOUT) {
            cJSON* json = cJSON_CreateObject();
            cJSON_AddStringToObject(json, "error", "Command execution timed out");
            cJSON_AddStringToObject(json, "command", command);
            free(result);
            return json_result(json);
        } else if (err != AGENTC_OK) {
            free(result);
            return json_error("Failed to execute command in sandbox");
        }
        
        /* Build response */
        cJSON* json = cJSON_CreateObject();
        cJSON_AddStringToObject(json, "command", command);
        cJSON_AddNumberToObject(json, "exit_code", exit_code);
        cJSON_AddStringToObject(json, "output", result);
        cJSON_AddBoolToObject(json, "sandboxed", 1);
        
        free(result);
        return json_result(json);
    }
    
    /* Non-sandbox mode: legacy execution */
    
    /* Safety check */
    if (g_safe_mode && is_dangerous_command(command)) {
        cJSON* json = cJSON_CreateObject();
        cJSON_AddStringToObject(json, "error", "Dangerous command blocked in safe mode");
        cJSON_AddStringToObject(json, "command", command);
        return json_result(json);
    }
    
    /* Execute command and capture output */
    char buffer[256];
    size_t result_len = 0;
    size_t result_cap = 4096;
    
    result = malloc(result_cap);
    if (!result) {
        return json_error("Memory allocation failed");
    }
    result[0] = '\0';
    
    FILE* fp = popen(command, "r");
    if (!fp) {
        free(result);
        return json_error("Failed to execute command");
    }
    
    while (fgets(buffer, sizeof(buffer), fp) != NULL) {
        size_t len = strlen(buffer);
        if (result_len + len + 1 > result_cap) {
            result_cap *= 2;
            char* new_result = realloc(result, result_cap);
            if (!new_result) {
                free(result);
                pclose(fp);
                return json_error("Memory allocation failed");
            }
            result = new_result;
        }
        strcpy(result + result_len, buffer);
        result_len += len;
    }
    
    int status = pclose(fp);
    exit_code = WEXITSTATUS(status);
    
    /* Build response */
    cJSON* json = cJSON_CreateObject();
    cJSON_AddStringToObject(json, "command", command);
    cJSON_AddNumberToObject(json, "exit_code", exit_code);
    cJSON_AddStringToObject(json, "output", result);
    
    free(result);
    return json_result(json);
}

/*============================================================================
 * Tool: read_file
 *============================================================================*/

const char* read_file(const char* path) {
    if (!path || strlen(path) == 0) {
        return json_error("path parameter is required");
    }
    
    /* Sandbox check (even if not "entered", check paths for file operations) */
    if (g_sandbox) {
        if (!ac_sandbox_check_path(g_sandbox, path, AC_SANDBOX_PERM_FS_READ)) {
            cJSON* json = cJSON_CreateObject();
            cJSON_AddStringToObject(json, "error", "File access blocked by sandbox");
            cJSON_AddStringToObject(json, "path", path);
            cJSON_AddStringToObject(json, "reason", ac_sandbox_denial_reason());
            cJSON_AddStringToObject(json, "ai_hint",
                "The sandbox policy prevents reading this file. "
                "The file may be outside the allowed workspace or readonly paths. "
                "Check if the file is within the project workspace.");
            return json_result(json);
        }
    }
    
    /* Open file */
    FILE* fp = fopen(path, "r");
    if (!fp) {
        cJSON* json = cJSON_CreateObject();
        cJSON_AddStringToObject(json, "error", "Failed to open file");
        cJSON_AddStringToObject(json, "path", path);
        return json_result(json);
    }
    
    /* Get file size */
    fseek(fp, 0, SEEK_END);
    long size = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    
    /* Limit file size to 100KB for safety */
    if (size > 100 * 1024) {
        fclose(fp);
        return json_error("File too large (max 100KB)");
    }
    
    /* Read file */
    char* content = malloc(size + 1);
    if (!content) {
        fclose(fp);
        return json_error("Memory allocation failed");
    }
    
    size_t read_size = fread(content, 1, size, fp);
    content[read_size] = '\0';
    fclose(fp);
    
    /* Build response */
    cJSON* json = cJSON_CreateObject();
    cJSON_AddStringToObject(json, "path", path);
    cJSON_AddNumberToObject(json, "size", (double)read_size);
    cJSON_AddStringToObject(json, "content", content);
    
    free(content);
    return json_result(json);
}

/*============================================================================
 * Tool: write_file
 *============================================================================*/

const char* write_file(const char* path, const char* content) {
    if (!path || strlen(path) == 0) {
        return json_error("path parameter is required");
    }
    
    if (!content) {
        return json_error("content parameter is required");
    }
    
    /* Sandbox check */
    if (g_sandbox) {
        unsigned int perms = AC_SANDBOX_PERM_FS_WRITE | AC_SANDBOX_PERM_FS_CREATE;
        if (!ac_sandbox_check_path(g_sandbox, path, perms)) {
            cJSON* json = cJSON_CreateObject();
            cJSON_AddStringToObject(json, "error", "File write blocked by sandbox");
            cJSON_AddStringToObject(json, "path", path);
            cJSON_AddStringToObject(json, "reason", ac_sandbox_denial_reason());
            cJSON_AddStringToObject(json, "ai_hint",
                "The sandbox policy prevents writing to this file. "
                "The path may be outside the allowed workspace. "
                "Only files within the project workspace can be created or modified.");
            return json_result(json);
        }
    }
    
    /* Write file */
    FILE* fp = fopen(path, "w");
    if (!fp) {
        cJSON* json = cJSON_CreateObject();
        cJSON_AddStringToObject(json, "error", "Failed to open file for writing");
        cJSON_AddStringToObject(json, "path", path);
        return json_result(json);
    }
    
    size_t written = fwrite(content, 1, strlen(content), fp);
    fclose(fp);
    
    /* Build response */
    cJSON* json = cJSON_CreateObject();
    cJSON_AddStringToObject(json, "path", path);
    cJSON_AddNumberToObject(json, "bytes_written", (double)written);
    cJSON_AddBoolToObject(json, "success", 1);
    
    return json_result(json);
}

/*============================================================================
 * Tool: list_directory
 *============================================================================*/

const char* list_directory(const char* path) {
    if (!path || strlen(path) == 0) {
        return json_error("path parameter is required");
    }
    
    /* Sandbox check */
    if (g_sandbox) {
        if (!ac_sandbox_check_path(g_sandbox, path, AC_SANDBOX_PERM_FS_READ)) {
            cJSON* json = cJSON_CreateObject();
            cJSON_AddStringToObject(json, "error", "Directory access blocked by sandbox");
            cJSON_AddStringToObject(json, "path", path);
            cJSON_AddStringToObject(json, "reason", ac_sandbox_denial_reason());
            cJSON_AddStringToObject(json, "ai_hint",
                "The sandbox policy prevents listing this directory. "
                "The directory may be outside the allowed workspace. "
                "Only directories within the project workspace can be listed.");
            return json_result(json);
        }
    }
    
    /* Open directory */
    DIR* dir = opendir(path);
    if (!dir) {
        cJSON* json = cJSON_CreateObject();
        cJSON_AddStringToObject(json, "error", "Failed to open directory");
        cJSON_AddStringToObject(json, "path", path);
        return json_result(json);
    }
    
    /* Build file list */
    cJSON* json = cJSON_CreateObject();
    cJSON_AddStringToObject(json, "path", path);
    cJSON* files = cJSON_CreateArray();
    
    struct dirent* entry;
    int count = 0;
    while ((entry = readdir(dir)) != NULL && count < 1000) {
        /* Skip . and .. */
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
            continue;
        }
        
        cJSON* file_obj = cJSON_CreateObject();
        cJSON_AddStringToObject(file_obj, "name", entry->d_name);
        
        /* Get file type */
        char full_path[1024];
        snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);
        struct stat st;
        if (stat(full_path, &st) == 0) {
            if (S_ISDIR(st.st_mode)) {
                cJSON_AddStringToObject(file_obj, "type", "directory");
            } else if (S_ISREG(st.st_mode)) {
                cJSON_AddStringToObject(file_obj, "type", "file");
                cJSON_AddNumberToObject(file_obj, "size", (double)st.st_size);
            } else {
                cJSON_AddStringToObject(file_obj, "type", "other");
            }
        }
        
        cJSON_AddItemToArray(files, file_obj);
        count++;
    }
    
    closedir(dir);
    
    cJSON_AddItemToObject(json, "files", files);
    cJSON_AddNumberToObject(json, "count", count);
    
    return json_result(json);
}

/*============================================================================
 * Tool: get_current_time
 *============================================================================*/

const char* get_current_time(void) {
    time_t now = time(NULL);
    struct tm* tm_info = localtime(&now);
    
    char date_buf[64];
    char time_buf[64];
    strftime(date_buf, sizeof(date_buf), "%Y-%m-%d", tm_info);
    strftime(time_buf, sizeof(time_buf), "%H:%M:%S", tm_info);
    
    cJSON* json = cJSON_CreateObject();
    cJSON_AddStringToObject(json, "date", date_buf);
    cJSON_AddStringToObject(json, "time", time_buf);
    cJSON_AddStringToObject(json, "timezone", "local");
    cJSON_AddNumberToObject(json, "timestamp", (double)now);
    
    return json_result(json);
}

/*============================================================================
 * Tool: calculator
 *============================================================================*/

double calculator(const char* operation, double a, double b) {
    if (!operation) {
        return 0.0;  /* Error case */
    }
    
    if (strcmp(operation, "add") == 0 || strcmp(operation, "+") == 0) {
        return a + b;
    } else if (strcmp(operation, "subtract") == 0 || strcmp(operation, "-") == 0) {
        return a - b;
    } else if (strcmp(operation, "multiply") == 0 || strcmp(operation, "*") == 0) {
        return a * b;
    } else if (strcmp(operation, "divide") == 0 || strcmp(operation, "/") == 0) {
        if (b == 0) {
            return 0.0 / 0.0;  /* NaN for division by zero */
        }
        return a / b;
    } else if (strcmp(operation, "power") == 0 || strcmp(operation, "^") == 0) {
        return pow(a, b);
    } else if (strcmp(operation, "mod") == 0 || strcmp(operation, "%") == 0) {
        return fmod(a, b);
    }
    
    return 0.0;  /* Unknown operation */
}
