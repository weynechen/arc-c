/**
 * @file test_moc.c
 * @brief Test program for MOC-generated code
 *
 * This program tests the wrapper functions and tool definitions generated by MOC.
 * Updated to use the new ac_tool_t API.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

/* Include the generated header */
#include "tools_gen.h"

/* Include cJSON for result parsing */
#include "cJSON.h"

/*============================================================================
 * Test Helpers
 *============================================================================*/

static int test_count = 0;
static int pass_count = 0;

#define TEST(name) \
    do { \
        printf("Test: %s... ", name); \
        test_count++; \
    } while(0)

#define PASS() \
    do { \
        printf("PASS\n"); \
        pass_count++; \
    } while(0)

#define FAIL(msg) \
    do { \
        printf("FAIL: %s\n", msg); \
    } while(0)

/*============================================================================
 * Helper: Find tool by name
 *============================================================================*/

static const ac_tool_t *find_tool(const char *name) {
    for (size_t i = 0; ALL_TOOLS[i] != NULL; i++) {
        if (strcmp(ALL_TOOLS[i]->name, name) == 0) {
            return ALL_TOOLS[i];
        }
    }
    return NULL;
}

/*============================================================================
 * Test Cases
 *============================================================================*/

void test_tool_count(void) {
    TEST("Tool count");
    
    /* We defined 5 AC_TOOL_META functions in sample_tools.h */
    if (ALL_TOOLS_COUNT >= 4 && ALL_TOOLS_COUNT <= 5) {
        PASS();
    } else {
        char msg[64];
        snprintf(msg, sizeof(msg), "Expected 4-5 tools, got %zu", ALL_TOOLS_COUNT);
        FAIL(msg);
    }
}

void test_tool_array_structure(void) {
    TEST("Tool array structure");
    
    /* Check that all entries have required fields */
    for (size_t i = 0; ALL_TOOLS[i] != NULL; i++) {
        const ac_tool_t *tool = ALL_TOOLS[i];
        if (tool->name == NULL || tool->description == NULL || 
            tool->parameters == NULL || tool->execute == NULL) {
            char msg[128];
            snprintf(msg, sizeof(msg), "Tool %zu missing required field", i);
            FAIL(msg);
            return;
        }
    }
    PASS();
}

void test_add_two_numbers_wrapper(void) {
    TEST("add_two_numbers wrapper");
    
    /* Find the tool */
    const ac_tool_t *tool = find_tool("add_two_numbers");
    if (!tool) {
        FAIL("Tool not found");
        return;
    }
    
    /* Call with JSON arguments (ctx and priv are NULL for testing) */
    char *result = tool->execute(NULL, "{\"a\": 5, \"b\": 3}", tool->priv);
    if (!result) {
        FAIL("Wrapper returned NULL");
        return;
    }
    
    /* Parse result */
    cJSON *json = cJSON_Parse(result);
    free(result);
    
    if (!json) {
        FAIL("Failed to parse result JSON");
        return;
    }
    
    cJSON *value = cJSON_GetObjectItem(json, "result");
    if (!value || !cJSON_IsNumber(value)) {
        cJSON_Delete(json);
        FAIL("Result field missing or not a number");
        return;
    }
    
    int res = (int)cJSON_GetNumberValue(value);
    cJSON_Delete(json);
    
    if (res == 8) {
        PASS();
    } else {
        char msg[64];
        snprintf(msg, sizeof(msg), "Expected 8, got %d", res);
        FAIL(msg);
    }
}

void test_get_weather_wrapper(void) {
    TEST("get_weather wrapper");
    
    /* Find the tool */
    const ac_tool_t *tool = find_tool("get_weather");
    if (!tool) {
        FAIL("Tool not found");
        return;
    }
    
    /* Call with JSON arguments */
    char *result = tool->execute(NULL, "{\"place\": \"Tokyo\"}", tool->priv);
    if (!result) {
        FAIL("Wrapper returned NULL");
        return;
    }
    
    /* Parse result */
    cJSON *json = cJSON_Parse(result);
    free(result);
    
    if (!json) {
        FAIL("Failed to parse result JSON");
        return;
    }
    
    cJSON *value = cJSON_GetObjectItem(json, "result");
    if (!value || !cJSON_IsString(value)) {
        cJSON_Delete(json);
        FAIL("Result field missing or not a string");
        return;
    }
    
    /* Just check that we got a string result */
    const char *weather = cJSON_GetStringValue(value);
    cJSON_Delete(json);
    
    if (weather && strlen(weather) > 0) {
        PASS();
    } else {
        FAIL("Empty weather result");
    }
}

void test_is_positive_wrapper(void) {
    TEST("is_positive wrapper");
    
    /* Find the tool */
    const ac_tool_t *tool = find_tool("is_positive");
    if (!tool) {
        FAIL("Tool not found");
        return;
    }
    
    /* Test positive number */
    char *result = tool->execute(NULL, "{\"value\": 42}", tool->priv);
    if (!result) {
        FAIL("Wrapper returned NULL");
        return;
    }
    
    cJSON *json = cJSON_Parse(result);
    free(result);
    
    if (!json) {
        FAIL("Failed to parse result JSON");
        return;
    }
    
    cJSON *value = cJSON_GetObjectItem(json, "result");
    bool is_pos = cJSON_IsTrue(value);
    cJSON_Delete(json);
    
    if (is_pos) {
        PASS();
    } else {
        FAIL("Expected true for positive number");
    }
}

void test_error_handling(void) {
    TEST("Error handling (invalid JSON)");
    
    /* Use the first tool */
    const ac_tool_t *tool = ALL_TOOLS[0];
    if (!tool) {
        FAIL("No tool available");
        return;
    }
    
    /* Call with invalid JSON */
    char *result = tool->execute(NULL, "not valid json", tool->priv);
    if (!result) {
        FAIL("Wrapper returned NULL instead of error");
        return;
    }
    
    /* Should contain error field */
    cJSON *json = cJSON_Parse(result);
    free(result);
    
    if (!json) {
        FAIL("Failed to parse error response");
        return;
    }
    
    cJSON *error = cJSON_GetObjectItem(json, "error");
    cJSON_Delete(json);
    
    if (error && cJSON_IsString(error)) {
        PASS();
    } else {
        FAIL("Expected error field in response");
    }
}

void test_parameters_format(void) {
    TEST("Parameters JSON Schema format");
    
    /* Parse one of the parameter schemas */
    const ac_tool_t *tool = ALL_TOOLS[0];
    if (!tool || !tool->parameters) {
        FAIL("No tool or parameters available");
        return;
    }
    
    cJSON *json = cJSON_Parse(tool->parameters);
    if (!json) {
        FAIL("Failed to parse parameters JSON");
        return;
    }
    
    /* Check it's a valid JSON Schema object */
    cJSON *type = cJSON_GetObjectItem(json, "type");
    cJSON *props = cJSON_GetObjectItem(json, "properties");
    
    if (!type || !cJSON_IsString(type) || strcmp(cJSON_GetStringValue(type), "object") != 0) {
        cJSON_Delete(json);
        FAIL("Parameters should have type: 'object'");
        return;
    }
    
    if (!props || !cJSON_IsObject(props)) {
        cJSON_Delete(json);
        FAIL("Parameters missing 'properties' object");
        return;
    }
    
    cJSON_Delete(json);
    PASS();
}

void test_tool_description(void) {
    TEST("Tool descriptions");
    
    /* Check that all tools have non-empty descriptions */
    for (size_t i = 0; ALL_TOOLS[i] != NULL; i++) {
        const ac_tool_t *tool = ALL_TOOLS[i];
        if (!tool->description || strlen(tool->description) == 0) {
            char msg[128];
            snprintf(msg, sizeof(msg), "Tool '%s' has empty description", tool->name);
            FAIL(msg);
            return;
        }
    }
    PASS();
}

/*============================================================================
 * Main
 *============================================================================*/

int main(void) {
    printf("=== MOC Generated Code Tests (New API) ===\n\n");
    
    test_tool_count();
    test_tool_array_structure();
    test_add_two_numbers_wrapper();
    test_get_weather_wrapper();
    test_is_positive_wrapper();
    test_error_handling();
    test_parameters_format();
    test_tool_description();
    
    printf("\n=== Results ===\n");
    printf("Passed: %d/%d\n", pass_count, test_count);
    
    return (pass_count == test_count) ? 0 : 1;
}
