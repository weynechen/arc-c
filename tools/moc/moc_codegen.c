/**
 * @file moc_codegen.c
 * @brief Code generation for MOC
 *
 * Generates wrapper functions and tool registration tables from
 * parsed tool metadata.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "moc.h"

/*============================================================================
 * Code Generation Templates
 *============================================================================*/

static const char *HEADER_TEMPLATE_START =
    "/**\n"
    " * @file %s.h\n"
    " * @brief Auto-generated tool definitions\n"
    " *\n"
    " * Generated by MOC (Meta-Object Compiler)\n"
    " * DO NOT EDIT - This file is automatically generated\n"
    " */\n"
    "\n"
    "#ifndef %s_H\n"
    "#define %s_H\n"
    "\n"
    "#include <stddef.h>\n"
    "\n"
    "#ifdef __cplusplus\n"
    "extern \"C\" {\n"
    "#endif\n"
    "\n"
    "/*============================================================================\n"
    " * Tool Entry Structure\n"
    " *============================================================================*/\n"
    "\n"
    "/* Use existing definition if available (e.g., from agentc/agent.h) */\n"
    "#ifndef AC_TOOL_ENTRY_DEFINED\n"
    "#define AC_TOOL_ENTRY_DEFINED\n"
    "\n"
    "/**\n"
    " * @brief Wrapper function signature for tool execution\n"
    " */\n"
    "typedef char* (*ac_tool_wrapper_t)(const char* json_args);\n"
    "\n"
    "/**\n"
    " * @brief Tool registry entry\n"
    " */\n"
    "typedef struct {\n"
    "    const char* name;           /**< Function name */\n"
    "    const char* schema;         /**< JSON Schema for parameters */\n"
    "    ac_tool_wrapper_t wrapper;  /**< Wrapper function pointer */\n"
    "} ac_tool_entry_t;\n"
    "\n"
    "#endif /* AC_TOOL_ENTRY_DEFINED */\n"
    "\n"
    "/*============================================================================\n"
    " * Generated Wrapper Declarations\n"
    " *============================================================================*/\n"
    "\n";

static const char *HEADER_TEMPLATE_END =
    "\n"
    "/*============================================================================\n"
    " * Tool Table\n"
    " *============================================================================*/\n"
    "\n"
    "/**\n"
    " * @brief Global tool registration table\n"
    " *\n"
    " * Usage:\n"
    " *   for (size_t i = 0; G_TOOL_TABLE[i].name != NULL; i++) {\n"
    " *       // Register tool...\n"
    " *   }\n"
    " */\n"
    "extern const ac_tool_entry_t G_TOOL_TABLE[];\n"
    "\n"
    "/**\n"
    " * @brief Get the number of tools in the table\n"
    " */\n"
    "extern size_t ac_tool_count(void);\n"
    "\n"
    "/**\n"
    " * @brief Find a tool by name\n"
    " *\n"
    " * @param name  Tool name to find\n"
    " * @return Pointer to tool entry, NULL if not found\n"
    " */\n"
    "const ac_tool_entry_t* ac_tool_find(const char* name);\n"
    "\n"
    "/**\n"
    " * @brief Execute a tool by name with JSON arguments\n"
    " *\n"
    " * @param name       Tool name\n"
    " * @param json_args  JSON string containing arguments\n"
    " * @return JSON string result (caller must free), NULL if tool not found\n"
    " */\n"
    "char* ac_tool_call(const char* name, const char* json_args);\n"
    "\n"
    "/**\n"
    " * @brief Get combined JSON schema for selected tools\n"
    " *\n"
    " * @param tool_names  NULL-terminated array of tool names\n"
    " * @return JSON array string of tool schemas (caller must free), NULL on error\n"
    " */\n"
    "char* ac_tools_schema(const char** tool_names);\n"
    "\n"
    "#ifdef __cplusplus\n"
    "}\n"
    "#endif\n"
    "\n"
    "#endif /* %s_H */\n";

static const char *SOURCE_TEMPLATE_START =
    "/**\n"
    " * @file %s.c\n"
    " * @brief Auto-generated tool wrappers and registration\n"
    " *\n"
    " * Generated by MOC (Meta-Object Compiler)\n"
    " * DO NOT EDIT - This file is automatically generated\n"
    " */\n"
    "\n"
    "#include <stdio.h>\n"
    "#include <stdlib.h>\n"
    "#include <string.h>\n"
    "#include <stdbool.h>\n"
    "#include \"%s.h\"\n"
    "#include \"cJSON.h\"\n"
    "\n"
    "/* Include the original header with tool declarations */\n"
    "#include \"%s\"\n"
    "\n"
    "/*============================================================================\n"
    " * Helper Macros\n"
    " *============================================================================*/\n"
    "\n"
    "#define WRAPPER_ERROR(msg) \\\n"
    "    do { \\\n"
    "        cJSON *err = cJSON_CreateObject(); \\\n"
    "        cJSON_AddStringToObject(err, \"error\", msg); \\\n"
    "        char *result = cJSON_PrintUnformatted(err); \\\n"
    "        cJSON_Delete(err); \\\n"
    "        return result; \\\n"
    "    } while(0)\n"
    "\n"
    "#define WRAPPER_RESULT_STRING(val) \\\n"
    "    do { \\\n"
    "        cJSON *res = cJSON_CreateObject(); \\\n"
    "        cJSON_AddStringToObject(res, \"result\", val ? val : \"\"); \\\n"
    "        char *result = cJSON_PrintUnformatted(res); \\\n"
    "        cJSON_Delete(res); \\\n"
    "        return result; \\\n"
    "    } while(0)\n"
    "\n"
    "#define WRAPPER_RESULT_INT(val) \\\n"
    "    do { \\\n"
    "        cJSON *res = cJSON_CreateObject(); \\\n"
    "        cJSON_AddNumberToObject(res, \"result\", (double)(val)); \\\n"
    "        char *result = cJSON_PrintUnformatted(res); \\\n"
    "        cJSON_Delete(res); \\\n"
    "        return result; \\\n"
    "    } while(0)\n"
    "\n"
    "#define WRAPPER_RESULT_FLOAT(val) \\\n"
    "    do { \\\n"
    "        cJSON *res = cJSON_CreateObject(); \\\n"
    "        cJSON_AddNumberToObject(res, \"result\", (double)(val)); \\\n"
    "        char *result = cJSON_PrintUnformatted(res); \\\n"
    "        cJSON_Delete(res); \\\n"
    "        return result; \\\n"
    "    } while(0)\n"
    "\n"
    "#define WRAPPER_RESULT_BOOL(val) \\\n"
    "    do { \\\n"
    "        cJSON *res = cJSON_CreateObject(); \\\n"
    "        cJSON_AddBoolToObject(res, \"result\", val); \\\n"
    "        char *result = cJSON_PrintUnformatted(res); \\\n"
    "        cJSON_Delete(res); \\\n"
    "        return result; \\\n"
    "    } while(0)\n"
    "\n"
    "#define WRAPPER_RESULT_VOID() \\\n"
    "    do { \\\n"
    "        cJSON *res = cJSON_CreateObject(); \\\n"
    "        cJSON_AddNullToObject(res, \"result\"); \\\n"
    "        char *result = cJSON_PrintUnformatted(res); \\\n"
    "        cJSON_Delete(res); \\\n"
    "        return result; \\\n"
    "    } while(0)\n"
    "\n"
    "/*============================================================================\n"
    " * JSON Schema Strings\n"
    " *============================================================================*/\n"
    "\n";

/*============================================================================
 * Helper Functions
 *============================================================================*/

/**
 * Escape a string for JSON
 */
static void escape_json_string(const char *src, char *dest, size_t dest_sz) {
    size_t j = 0;
    for (size_t i = 0; src[i] && j < dest_sz - 2; i++) {
        char c = src[i];
        switch (c) {
            case '"':  dest[j++] = '\\'; if (j < dest_sz - 1) dest[j++] = '"'; break;
            case '\\': dest[j++] = '\\'; if (j < dest_sz - 1) dest[j++] = '\\'; break;
            case '\n': dest[j++] = '\\'; if (j < dest_sz - 1) dest[j++] = 'n'; break;
            case '\r': dest[j++] = '\\'; if (j < dest_sz - 1) dest[j++] = 'r'; break;
            case '\t': dest[j++] = '\\'; if (j < dest_sz - 1) dest[j++] = 't'; break;
            default:   dest[j++] = c; break;
        }
    }
    dest[j] = '\0';
}

/**
 * Generate uppercase version of string for header guard
 */
static void to_upper_underscore(const char *src, char *dest, size_t dest_sz) {
    size_t j = 0;
    for (size_t i = 0; src[i] && j < dest_sz - 1; i++) {
        char c = src[i];
        if (c >= 'a' && c <= 'z') {
            dest[j++] = c - 'a' + 'A';
        } else if ((c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9')) {
            dest[j++] = c;
        } else {
            dest[j++] = '_';
        }
    }
    dest[j] = '\0';
}

/**
 * Get base name from file path
 */
static const char *get_basename(const char *path) {
    const char *base = strrchr(path, '/');
    if (base) {
        return base + 1;
    }
    base = strrchr(path, '\\');
    if (base) {
        return base + 1;
    }
    return path;
}

/*============================================================================
 * Schema Generation
 *============================================================================*/

/**
 * Generate JSON Schema for a tool's parameters
 *
 * The schema is generated as a single string literal to ensure it's
 * a compile-time constant that can be used in static initializers.
 */
static void generate_schema(FILE *out, const moc_tool_t *tool) {
    char escaped_desc[MOC_MAX_DESC_LEN * 2];
    escape_json_string(tool->description, escaped_desc, sizeof(escaped_desc));

    /* Build schema as a single line string literal */
    fprintf(out, "static const char SCHEMA_%s[] = ", tool->name);
    fprintf(out, "\"{");
    fprintf(out, "\\\"type\\\": \\\"function\\\", ");
    fprintf(out, "\\\"function\\\": {");
    fprintf(out, "\\\"name\\\": \\\"%s\\\", ", tool->name);
    fprintf(out, "\\\"description\\\": \\\"%s\\\", ", escaped_desc);
    fprintf(out, "\\\"parameters\\\": {");
    fprintf(out, "\\\"type\\\": \\\"object\\\", ");
    fprintf(out, "\\\"properties\\\": {");

    for (int i = 0; i < tool->param_count; i++) {
        const moc_param_t *param = &tool->params[i];
        char escaped_param_desc[MOC_MAX_DESC_LEN * 2];
        escape_json_string(param->description, escaped_param_desc, sizeof(escaped_param_desc));

        fprintf(out, "\\\"%s\\\": {", param->name);
        fprintf(out, "\\\"type\\\": \\\"%s\\\", ", moc_type_to_json_schema(param->type));
        fprintf(out, "\\\"description\\\": \\\"%s\\\"", escaped_param_desc);
        fprintf(out, "}%s", (i < tool->param_count - 1) ? ", " : "");
    }

    fprintf(out, "}, ");
    fprintf(out, "\\\"required\\\": [");

    for (int i = 0; i < tool->param_count; i++) {
        fprintf(out, "\\\"%s\\\"%s", 
                tool->params[i].name,
                (i < tool->param_count - 1) ? ", " : "");
    }

    fprintf(out, "]");
    fprintf(out, "}");
    fprintf(out, "}");
    fprintf(out, "}\";\n\n");
}

/*============================================================================
 * Wrapper Generation
 *============================================================================*/

/**
 * Generate argument extraction code for a parameter
 */
static void generate_param_extraction(FILE *out, const moc_param_t *param) {
    switch (param->type) {
        case MOC_TYPE_STRING:
            fprintf(out, "    cJSON *json_%s = cJSON_GetObjectItem(root, \"%s\");\n",
                    param->name, param->name);
            fprintf(out, "    if (!json_%s || !cJSON_IsString(json_%s)) {\n",
                    param->name, param->name);
            fprintf(out, "        cJSON_Delete(root);\n");
            fprintf(out, "        WRAPPER_ERROR(\"Missing or invalid parameter: %s\");\n",
                    param->name);
            fprintf(out, "    }\n");
            fprintf(out, "    const char *arg_%s = cJSON_GetStringValue(json_%s);\n\n",
                    param->name, param->name);
            break;

        case MOC_TYPE_INT:
            fprintf(out, "    cJSON *json_%s = cJSON_GetObjectItem(root, \"%s\");\n",
                    param->name, param->name);
            fprintf(out, "    if (!json_%s || !cJSON_IsNumber(json_%s)) {\n",
                    param->name, param->name);
            fprintf(out, "        cJSON_Delete(root);\n");
            fprintf(out, "        WRAPPER_ERROR(\"Missing or invalid parameter: %s\");\n",
                    param->name);
            fprintf(out, "    }\n");
            fprintf(out, "    int arg_%s = (int)cJSON_GetNumberValue(json_%s);\n\n",
                    param->name, param->name);
            break;

        case MOC_TYPE_FLOAT:
            fprintf(out, "    cJSON *json_%s = cJSON_GetObjectItem(root, \"%s\");\n",
                    param->name, param->name);
            fprintf(out, "    if (!json_%s || !cJSON_IsNumber(json_%s)) {\n",
                    param->name, param->name);
            fprintf(out, "        cJSON_Delete(root);\n");
            fprintf(out, "        WRAPPER_ERROR(\"Missing or invalid parameter: %s\");\n",
                    param->name);
            fprintf(out, "    }\n");
            fprintf(out, "    double arg_%s = cJSON_GetNumberValue(json_%s);\n\n",
                    param->name, param->name);
            break;

        case MOC_TYPE_BOOL:
            fprintf(out, "    cJSON *json_%s = cJSON_GetObjectItem(root, \"%s\");\n",
                    param->name, param->name);
            fprintf(out, "    if (!json_%s || !cJSON_IsBool(json_%s)) {\n",
                    param->name, param->name);
            fprintf(out, "        cJSON_Delete(root);\n");
            fprintf(out, "        WRAPPER_ERROR(\"Missing or invalid parameter: %s\");\n",
                    param->name);
            fprintf(out, "    }\n");
            fprintf(out, "    bool arg_%s = cJSON_IsTrue(json_%s);\n\n",
                    param->name, param->name);
            break;

        default:
            fprintf(out, "    /* Unknown type for parameter %s, treating as string */\n",
                    param->name);
            fprintf(out, "    cJSON *json_%s = cJSON_GetObjectItem(root, \"%s\");\n",
                    param->name, param->name);
            fprintf(out, "    const char *arg_%s = json_%s ? cJSON_GetStringValue(json_%s) : \"\";\n\n",
                    param->name, param->name, param->name);
            break;
    }
}

/**
 * Generate wrapper function for a tool
 */
static void generate_wrapper(FILE *out, const moc_tool_t *tool) {
    fprintf(out, "/**\n");
    fprintf(out, " * @brief Wrapper for %s\n", tool->name);
    fprintf(out, " */\n");
    fprintf(out, "char* __wrapper_%s(const char* json_args) {\n", tool->name);
    fprintf(out, "    cJSON *root = cJSON_Parse(json_args);\n");
    fprintf(out, "    if (!root) {\n");
    fprintf(out, "        WRAPPER_ERROR(\"Failed to parse JSON arguments\");\n");
    fprintf(out, "    }\n\n");

    /* Generate parameter extraction */
    for (int i = 0; i < tool->param_count; i++) {
        generate_param_extraction(out, &tool->params[i]);
    }

    /* Generate function call */
    fprintf(out, "    /* Call the actual function */\n");

    if (tool->return_type_cat == MOC_TYPE_VOID) {
        fprintf(out, "    %s(", tool->name);
    } else {
        /* Determine the C variable type for the result */
        const char *result_type;
        switch (tool->return_type_cat) {
            case MOC_TYPE_STRING: result_type = "const char*"; break;
            case MOC_TYPE_INT:    result_type = "int"; break;
            case MOC_TYPE_FLOAT:  result_type = "double"; break;
            case MOC_TYPE_BOOL:   result_type = "bool"; break;
            default:              result_type = tool->return_type; break;
        }
        fprintf(out, "    %s result = %s(", result_type, tool->name);
    }

    /* Generate argument list */
    for (int i = 0; i < tool->param_count; i++) {
        fprintf(out, "arg_%s%s", tool->params[i].name,
                (i < tool->param_count - 1) ? ", " : "");
    }
    fprintf(out, ");\n\n");

    /* Clean up and return result */
    fprintf(out, "    cJSON_Delete(root);\n\n");

    switch (tool->return_type_cat) {
        case MOC_TYPE_STRING:
            fprintf(out, "    WRAPPER_RESULT_STRING(result);\n");
            break;
        case MOC_TYPE_INT:
            fprintf(out, "    WRAPPER_RESULT_INT(result);\n");
            break;
        case MOC_TYPE_FLOAT:
            fprintf(out, "    WRAPPER_RESULT_FLOAT(result);\n");
            break;
        case MOC_TYPE_BOOL:
            fprintf(out, "    WRAPPER_RESULT_BOOL(result);\n");
            break;
        case MOC_TYPE_VOID:
            fprintf(out, "    WRAPPER_RESULT_VOID();\n");
            break;
        default:
            fprintf(out, "    WRAPPER_RESULT_STRING(result);\n");
            break;
    }

    fprintf(out, "}\n\n");
}

/*============================================================================
 * Main Generation Functions
 *============================================================================*/

int moc_generate_header(moc_ctx_t *ctx, FILE *out) {
    if (!out) out = stdout;

    /* Generate base name for file (use just the filename, not full path) */
    char base_name[256] = "tools_gen";
    if (ctx->output_base) {
        const char *name = get_basename(ctx->output_base);
        strncpy(base_name, name, sizeof(base_name) - 1);
        base_name[sizeof(base_name) - 1] = '\0';
    }

    char guard_name[256];
    to_upper_underscore(base_name, guard_name, sizeof(guard_name));

    /* Write header start */
    fprintf(out, HEADER_TEMPLATE_START, base_name, guard_name, guard_name);

    /* Write wrapper declarations */
    for (int i = 0; i < ctx->tool_count; i++) {
        fprintf(out, "char* __wrapper_%s(const char* json_args);\n", 
                ctx->tools[i].name);
    }

    /* Write header end */
    fprintf(out, HEADER_TEMPLATE_END, guard_name);

    return 0;
}

int moc_generate_source(moc_ctx_t *ctx, FILE *out) {
    if (!out) out = stdout;

    /* Generate base name for file (use just the filename, not full path) */
    char base_name[256] = "tools_gen";
    if (ctx->output_base) {
        const char *name = get_basename(ctx->output_base);
        strncpy(base_name, name, sizeof(base_name) - 1);
        base_name[sizeof(base_name) - 1] = '\0';
    }

    /* Get input file base name */
    const char *input_basename = get_basename(ctx->input_file);

    /* Write source start */
    fprintf(out, SOURCE_TEMPLATE_START, base_name, base_name, input_basename);

    /* Generate schemas */
    for (int i = 0; i < ctx->tool_count; i++) {
        generate_schema(out, &ctx->tools[i]);
    }

    /* Write wrappers section header */
    fprintf(out, "/*============================================================================\n");
    fprintf(out, " * Wrapper Functions\n");
    fprintf(out, " *============================================================================*/\n\n");

    /* Generate wrapper functions */
    for (int i = 0; i < ctx->tool_count; i++) {
        generate_wrapper(out, &ctx->tools[i]);
    }

    /* Write tool table section */
    fprintf(out, "/*============================================================================\n");
    fprintf(out, " * Tool Registration Table\n");
    fprintf(out, " *============================================================================*/\n\n");

    fprintf(out, "const ac_tool_entry_t G_TOOL_TABLE[] = {\n");
    for (int i = 0; i < ctx->tool_count; i++) {
        fprintf(out, "    { \"%s\", SCHEMA_%s, __wrapper_%s },\n",
                ctx->tools[i].name, ctx->tools[i].name, ctx->tools[i].name);
    }
    fprintf(out, "    { NULL, NULL, NULL }  /* Sentinel */\n");
    fprintf(out, "};\n\n");

    fprintf(out, "size_t ac_tool_count(void) {\n");
    fprintf(out, "    return %d;\n", ctx->tool_count);
    fprintf(out, "}\n\n");

    /* Generate ac_tool_find function */
    fprintf(out, "const ac_tool_entry_t* ac_tool_find(const char* name) {\n");
    fprintf(out, "    if (!name) return NULL;\n");
    fprintf(out, "    for (size_t i = 0; G_TOOL_TABLE[i].name != NULL; i++) {\n");
    fprintf(out, "        if (strcmp(G_TOOL_TABLE[i].name, name) == 0) {\n");
    fprintf(out, "            return &G_TOOL_TABLE[i];\n");
    fprintf(out, "        }\n");
    fprintf(out, "    }\n");
    fprintf(out, "    return NULL;\n");
    fprintf(out, "}\n\n");

    /* Generate ac_tool_call function */
    fprintf(out, "char* ac_tool_call(const char* name, const char* json_args) {\n");
    fprintf(out, "    const ac_tool_entry_t* tool = ac_tool_find(name);\n");
    fprintf(out, "    if (!tool || !tool->wrapper) {\n");
    fprintf(out, "        return NULL;\n");
    fprintf(out, "    }\n");
    fprintf(out, "    return tool->wrapper(json_args);\n");
    fprintf(out, "}\n\n");

    /* Generate ac_tools_schema function */
    fprintf(out, "char* ac_tools_schema(const char** tool_names) {\n");
    fprintf(out, "    if (!tool_names) return NULL;\n");
    fprintf(out, "    \n");
    fprintf(out, "    /* Calculate required buffer size */\n");
    fprintf(out, "    size_t total_len = 2; /* [] */\n");
    fprintf(out, "    int count = 0;\n");
    fprintf(out, "    for (const char** p = tool_names; *p != NULL; p++) {\n");
    fprintf(out, "        const ac_tool_entry_t* tool = ac_tool_find(*p);\n");
    fprintf(out, "        if (tool && tool->schema) {\n");
    fprintf(out, "            total_len += strlen(tool->schema) + 1; /* +1 for comma */\n");
    fprintf(out, "            count++;\n");
    fprintf(out, "        }\n");
    fprintf(out, "    }\n");
    fprintf(out, "    \n");
    fprintf(out, "    if (count == 0) {\n");
    fprintf(out, "        char* empty = malloc(3);\n");
    fprintf(out, "        if (empty) strcpy(empty, \"[]\");\n");
    fprintf(out, "        return empty;\n");
    fprintf(out, "    }\n");
    fprintf(out, "    \n");
    fprintf(out, "    char* result = malloc(total_len + 1);\n");
    fprintf(out, "    if (!result) return NULL;\n");
    fprintf(out, "    \n");
    fprintf(out, "    char* ptr = result;\n");
    fprintf(out, "    *ptr++ = '[';\n");
    fprintf(out, "    \n");
    fprintf(out, "    int first = 1;\n");
    fprintf(out, "    for (const char** p = tool_names; *p != NULL; p++) {\n");
    fprintf(out, "        const ac_tool_entry_t* tool = ac_tool_find(*p);\n");
    fprintf(out, "        if (tool && tool->schema) {\n");
    fprintf(out, "            if (!first) *ptr++ = ',';\n");
    fprintf(out, "            first = 0;\n");
    fprintf(out, "            size_t len = strlen(tool->schema);\n");
    fprintf(out, "            memcpy(ptr, tool->schema, len);\n");
    fprintf(out, "            ptr += len;\n");
    fprintf(out, "        }\n");
    fprintf(out, "    }\n");
    fprintf(out, "    \n");
    fprintf(out, "    *ptr++ = ']';\n");
    fprintf(out, "    *ptr = '\\0';\n");
    fprintf(out, "    \n");
    fprintf(out, "    return result;\n");
    fprintf(out, "}\n");

    return 0;
}

int moc_generate(moc_ctx_t *ctx) {
    if (ctx->tool_count == 0) {
        fprintf(stderr, "Warning: No tools found to generate\n");
        return 0;
    }

    if (!ctx->output_base) {
        /* Output to stdout */
        fprintf(stdout, "/* ===== GENERATED HEADER ===== */\n\n");
        moc_generate_header(ctx, stdout);
        fprintf(stdout, "\n/* ===== GENERATED SOURCE ===== */\n\n");
        moc_generate_source(ctx, stdout);
        return 0;
    }

    /* Generate header file */
    char header_path[512];
    snprintf(header_path, sizeof(header_path), "%s.h", ctx->output_base);

    FILE *header_file = fopen(header_path, "w");
    if (!header_file) {
        fprintf(stderr, "Error: Failed to open %s for writing\n", header_path);
        return -1;
    }

    if (moc_generate_header(ctx, header_file) != 0) {
        fclose(header_file);
        return -1;
    }
    fclose(header_file);

    if (ctx->verbose) {
        printf("Generated: %s\n", header_path);
    }

    /* Generate source file */
    char source_path[512];
    snprintf(source_path, sizeof(source_path), "%s.c", ctx->output_base);

    FILE *source_file = fopen(source_path, "w");
    if (!source_file) {
        fprintf(stderr, "Error: Failed to open %s for writing\n", source_path);
        return -1;
    }

    if (moc_generate_source(ctx, source_file) != 0) {
        fclose(source_file);
        return -1;
    }
    fclose(source_file);

    if (ctx->verbose) {
        printf("Generated: %s\n", source_path);
    }

    return 0;
}
