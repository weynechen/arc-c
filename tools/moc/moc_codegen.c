/**
 * @file moc_codegen.c
 * @brief Code generation for MOC
 *
 * Generates wrapper functions and tool registration using the new
 * ac_tool_t structure with unified signature.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "moc.h"

/*============================================================================
 * Code Generation Templates
 *============================================================================*/

static const char *HEADER_TEMPLATE_START =
    "/**\n"
    " * @file %s.h\n"
    " * @brief Auto-generated tool definitions\n"
    " *\n"
    " * Generated by MOC (Meta-Object Compiler)\n"
    " * DO NOT EDIT - This file is automatically generated\n"
    " */\n"
    "\n"
    "#ifndef %s_H\n"
    "#define %s_H\n"
    "\n"
    "#include <agentc/tool.h>\n"
    "\n"
    "#ifdef __cplusplus\n"
    "extern \"C\" {\n"
    "#endif\n"
    "\n"
    "/*============================================================================\n"
    " * Tool Declarations\n"
    " *============================================================================*/\n"
    "\n";

static const char *HEADER_TEMPLATE_ALL_TOOLS =
    "\n"
    "/*============================================================================\n"
    " * All Tools Array\n"
    " *============================================================================*/\n"
    "\n"
    "/**\n"
    " * @brief Array of all generated tools\n"
    " *\n"
    " * Usage:\n"
    " *   ac_tool_registry_add_array(registry, ALL_TOOLS);\n"
    " */\n"
    "extern const ac_tool_t *ALL_TOOLS[];\n"
    "extern const size_t ALL_TOOLS_COUNT;\n"
    "\n";

static const char *HEADER_TEMPLATE_END =
    "\n"
    "#ifdef __cplusplus\n"
    "}\n"
    "#endif\n"
    "\n"
    "#endif /* %s_H */\n";

static const char *SOURCE_TEMPLATE_START =
    "/**\n"
    " * @file %s.c\n"
    " * @brief Auto-generated tool wrappers and definitions\n"
    " *\n"
    " * Generated by MOC (Meta-Object Compiler)\n"
    " * DO NOT EDIT - This file is automatically generated\n"
    " */\n"
    "\n"
    "#include <stdio.h>\n"
    "#include <stdlib.h>\n"
    "#include <string.h>\n"
    "#include <stdbool.h>\n"
    "#include \"%s.h\"\n"
    "#include \"cJSON.h\"\n"
    "\n"
    "/* Include the original header with tool declarations */\n"
    "#include \"%s\"\n"
    "\n"
    "/*============================================================================\n"
    " * Helper Macros\n"
    " *============================================================================*/\n"
    "\n"
    "#define WRAPPER_ERROR(msg) \\\n"
    "    do { \\\n"
    "        cJSON *err = cJSON_CreateObject(); \\\n"
    "        cJSON_AddStringToObject(err, \"error\", msg); \\\n"
    "        char *result = cJSON_PrintUnformatted(err); \\\n"
    "        cJSON_Delete(err); \\\n"
    "        return result; \\\n"
    "    } while(0)\n"
    "\n"
    "#define WRAPPER_RESULT_STRING(val) \\\n"
    "    do { \\\n"
    "        cJSON *res = cJSON_CreateObject(); \\\n"
    "        cJSON_AddStringToObject(res, \"result\", val ? val : \"\"); \\\n"
    "        char *result = cJSON_PrintUnformatted(res); \\\n"
    "        cJSON_Delete(res); \\\n"
    "        return result; \\\n"
    "    } while(0)\n"
    "\n"
    "#define WRAPPER_RESULT_INT(val) \\\n"
    "    do { \\\n"
    "        cJSON *res = cJSON_CreateObject(); \\\n"
    "        cJSON_AddNumberToObject(res, \"result\", (double)(val)); \\\n"
    "        char *result = cJSON_PrintUnformatted(res); \\\n"
    "        cJSON_Delete(res); \\\n"
    "        return result; \\\n"
    "    } while(0)\n"
    "\n"
    "#define WRAPPER_RESULT_FLOAT(val) \\\n"
    "    do { \\\n"
    "        cJSON *res = cJSON_CreateObject(); \\\n"
    "        cJSON_AddNumberToObject(res, \"result\", (double)(val)); \\\n"
    "        char *result = cJSON_PrintUnformatted(res); \\\n"
    "        cJSON_Delete(res); \\\n"
    "        return result; \\\n"
    "    } while(0)\n"
    "\n"
    "#define WRAPPER_RESULT_BOOL(val) \\\n"
    "    do { \\\n"
    "        cJSON *res = cJSON_CreateObject(); \\\n"
    "        cJSON_AddBoolToObject(res, \"result\", val); \\\n"
    "        char *result = cJSON_PrintUnformatted(res); \\\n"
    "        cJSON_Delete(res); \\\n"
    "        return result; \\\n"
    "    } while(0)\n"
    "\n"
    "#define WRAPPER_RESULT_VOID() \\\n"
    "    do { \\\n"
    "        cJSON *res = cJSON_CreateObject(); \\\n"
    "        cJSON_AddNullToObject(res, \"result\"); \\\n"
    "        char *result = cJSON_PrintUnformatted(res); \\\n"
    "        cJSON_Delete(res); \\\n"
    "        return result; \\\n"
    "    } while(0)\n"
    "\n";

/*============================================================================
 * Helper Functions
 *============================================================================*/

/**
 * Escape a string for JSON
 */
static void escape_json_string(const char *src, char *dest, size_t dest_sz) {
    size_t j = 0;
    for (size_t i = 0; src[i] && j < dest_sz - 2; i++) {
        char c = src[i];
        switch (c) {
            case '"':  dest[j++] = '\\'; if (j < dest_sz - 1) dest[j++] = '"'; break;
            case '\\': dest[j++] = '\\'; if (j < dest_sz - 1) dest[j++] = '\\'; break;
            case '\n': dest[j++] = '\\'; if (j < dest_sz - 1) dest[j++] = 'n'; break;
            case '\r': dest[j++] = '\\'; if (j < dest_sz - 1) dest[j++] = 'r'; break;
            case '\t': dest[j++] = '\\'; if (j < dest_sz - 1) dest[j++] = 't'; break;
            default:   dest[j++] = c; break;
        }
    }
    dest[j] = '\0';
}

/**
 * Generate uppercase version of string for header guard
 */
static void to_upper_underscore(const char *src, char *dest, size_t dest_sz) {
    size_t j = 0;
    for (size_t i = 0; src[i] && j < dest_sz - 1; i++) {
        char c = src[i];
        if (c >= 'a' && c <= 'z') {
            dest[j++] = c - 'a' + 'A';
        } else if ((c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9')) {
            dest[j++] = c;
        } else {
            dest[j++] = '_';
        }
    }
    dest[j] = '\0';
}

/**
 * Get base name from file path
 */
static const char *get_basename(const char *path) {
    const char *base = strrchr(path, '/');
    if (base) {
        return base + 1;
    }
    base = strrchr(path, '\\');
    if (base) {
        return base + 1;
    }
    return path;
}

/*============================================================================
 * Description and Parameters Schema Generation
 *============================================================================*/

/**
 * Generate description string constant
 */
static void generate_description(FILE *out, const moc_tool_t *tool) {
    char escaped_desc[MOC_MAX_DESC_LEN * 2];
    escape_json_string(tool->description, escaped_desc, sizeof(escaped_desc));
    
    fprintf(out, "static const char DESC_%s[] = \"%s\";\n\n", 
            tool->name, escaped_desc);
}

/**
 * Generate parameters JSON Schema string constant
 */
static void generate_parameters_schema(FILE *out, const moc_tool_t *tool) {
    fprintf(out, "static const char PARAMS_%s[] = \n", tool->name);
    fprintf(out, "    \"{\\\"type\\\":\\\"object\\\",\"\n");
    fprintf(out, "    \"\\\"properties\\\":{");
    
    for (int i = 0; i < tool->param_count; i++) {
        const moc_param_t *param = &tool->params[i];
        char escaped_desc[MOC_MAX_DESC_LEN * 2];
        escape_json_string(param->description, escaped_desc, sizeof(escaped_desc));
        
        fprintf(out, "\\\"%s\\\":{\\\"type\\\":\\\"%s\\\",\\\"description\\\":\\\"%s\\\"}",
                param->name, moc_type_to_json_schema(param->type), escaped_desc);
        
        if (i < tool->param_count - 1) {
            fprintf(out, ",");
        }
    }
    
    fprintf(out, "},\"\n");
    fprintf(out, "    \"\\\"required\\\":[");
    
    for (int i = 0; i < tool->param_count; i++) {
        fprintf(out, "\\\"%s\\\"", tool->params[i].name);
        if (i < tool->param_count - 1) {
            fprintf(out, ",");
        }
    }
    
    fprintf(out, "]}\";\n\n");
}

/*============================================================================
 * Wrapper Generation
 *============================================================================*/

/**
 * Generate argument extraction code for a parameter
 */
static void generate_param_extraction(FILE *out, const moc_param_t *param) {
    switch (param->type) {
        case MOC_TYPE_STRING:
            fprintf(out, "    cJSON *json_%s = cJSON_GetObjectItem(root, \"%s\");\n",
                    param->name, param->name);
            fprintf(out, "    if (!json_%s || !cJSON_IsString(json_%s)) {\n",
                    param->name, param->name);
            fprintf(out, "        cJSON_Delete(root);\n");
            fprintf(out, "        WRAPPER_ERROR(\"Missing or invalid parameter: %s\");\n",
                    param->name);
            fprintf(out, "    }\n");
            fprintf(out, "    const char *arg_%s = cJSON_GetStringValue(json_%s);\n\n",
                    param->name, param->name);
            break;

        case MOC_TYPE_INT:
            fprintf(out, "    cJSON *json_%s = cJSON_GetObjectItem(root, \"%s\");\n",
                    param->name, param->name);
            fprintf(out, "    if (!json_%s || !cJSON_IsNumber(json_%s)) {\n",
                    param->name, param->name);
            fprintf(out, "        cJSON_Delete(root);\n");
            fprintf(out, "        WRAPPER_ERROR(\"Missing or invalid parameter: %s\");\n",
                    param->name);
            fprintf(out, "    }\n");
            fprintf(out, "    int arg_%s = (int)cJSON_GetNumberValue(json_%s);\n\n",
                    param->name, param->name);
            break;

        case MOC_TYPE_FLOAT:
            fprintf(out, "    cJSON *json_%s = cJSON_GetObjectItem(root, \"%s\");\n",
                    param->name, param->name);
            fprintf(out, "    if (!json_%s || !cJSON_IsNumber(json_%s)) {\n",
                    param->name, param->name);
            fprintf(out, "        cJSON_Delete(root);\n");
            fprintf(out, "        WRAPPER_ERROR(\"Missing or invalid parameter: %s\");\n",
                    param->name);
            fprintf(out, "    }\n");
            fprintf(out, "    double arg_%s = cJSON_GetNumberValue(json_%s);\n\n",
                    param->name, param->name);
            break;

        case MOC_TYPE_BOOL:
            fprintf(out, "    cJSON *json_%s = cJSON_GetObjectItem(root, \"%s\");\n",
                    param->name, param->name);
            fprintf(out, "    if (!json_%s || !cJSON_IsBool(json_%s)) {\n",
                    param->name, param->name);
            fprintf(out, "        cJSON_Delete(root);\n");
            fprintf(out, "        WRAPPER_ERROR(\"Missing or invalid parameter: %s\");\n",
                    param->name);
            fprintf(out, "    }\n");
            fprintf(out, "    bool arg_%s = cJSON_IsTrue(json_%s);\n\n",
                    param->name, param->name);
            break;

        default:
            fprintf(out, "    /* Unknown type for parameter %s, treating as string */\n",
                    param->name);
            fprintf(out, "    cJSON *json_%s = cJSON_GetObjectItem(root, \"%s\");\n",
                    param->name, param->name);
            fprintf(out, "    const char *arg_%s = json_%s ? cJSON_GetStringValue(json_%s) : \"\";\n\n",
                    param->name, param->name, param->name);
            break;
    }
}

/**
 * Generate wrapper function with new unified signature
 */
static void generate_wrapper(FILE *out, const moc_tool_t *tool) {
    fprintf(out, "/**\n");
    fprintf(out, " * @brief Wrapper for %s\n", tool->name);
    fprintf(out, " */\n");
    /* New signature: (ctx, args_json, priv) */
    fprintf(out, "static char* exec_%s(\n", tool->name);
    fprintf(out, "    const ac_tool_ctx_t *ctx,\n");
    fprintf(out, "    const char *args_json,\n");
    fprintf(out, "    void *priv\n");
    fprintf(out, ") {\n");
    fprintf(out, "    (void)ctx;  /* May be unused */\n");
    fprintf(out, "    (void)priv; /* Not used for builtin tools */\n");
    fprintf(out, "\n");
    fprintf(out, "    cJSON *root = cJSON_Parse(args_json);\n");
    fprintf(out, "    if (!root) {\n");
    fprintf(out, "        WRAPPER_ERROR(\"Failed to parse JSON arguments\");\n");
    fprintf(out, "    }\n\n");

    /* Generate parameter extraction */
    for (int i = 0; i < tool->param_count; i++) {
        generate_param_extraction(out, &tool->params[i]);
    }

    /* Generate function call */
    fprintf(out, "    /* Call the actual function */\n");

    if (tool->return_type_cat == MOC_TYPE_VOID) {
        fprintf(out, "    %s(", tool->name);
    } else {
        /* Determine the C variable type for the result */
        const char *result_type;
        switch (tool->return_type_cat) {
            case MOC_TYPE_STRING: result_type = "const char*"; break;
            case MOC_TYPE_INT:    result_type = "int"; break;
            case MOC_TYPE_FLOAT:  result_type = "double"; break;
            case MOC_TYPE_BOOL:   result_type = "bool"; break;
            default:              result_type = tool->return_type; break;
        }
        fprintf(out, "    %s result = %s(", result_type, tool->name);
    }

    /* Generate argument list */
    for (int i = 0; i < tool->param_count; i++) {
        fprintf(out, "arg_%s%s", tool->params[i].name,
                (i < tool->param_count - 1) ? ", " : "");
    }
    fprintf(out, ");\n\n");

    /* Clean up and return result */
    fprintf(out, "    cJSON_Delete(root);\n\n");

    switch (tool->return_type_cat) {
        case MOC_TYPE_STRING:
            fprintf(out, "    WRAPPER_RESULT_STRING(result);\n");
            break;
        case MOC_TYPE_INT:
            fprintf(out, "    WRAPPER_RESULT_INT(result);\n");
            break;
        case MOC_TYPE_FLOAT:
            fprintf(out, "    WRAPPER_RESULT_FLOAT(result);\n");
            break;
        case MOC_TYPE_BOOL:
            fprintf(out, "    WRAPPER_RESULT_BOOL(result);\n");
            break;
        case MOC_TYPE_VOID:
            fprintf(out, "    WRAPPER_RESULT_VOID();\n");
            break;
        default:
            fprintf(out, "    WRAPPER_RESULT_STRING(result);\n");
            break;
    }

    fprintf(out, "}\n\n");
}

/**
 * Generate tool definition constant
 */
static void generate_tool_definition(FILE *out, const moc_tool_t *tool) {
    fprintf(out, "const ac_tool_t TOOL_%s = {\n", tool->name);
    fprintf(out, "    .name = \"%s\",\n", tool->name);
    fprintf(out, "    .description = DESC_%s,\n", tool->name);
    fprintf(out, "    .parameters = PARAMS_%s,\n", tool->name);
    fprintf(out, "    .execute = exec_%s,\n", tool->name);
    fprintf(out, "    .priv = NULL\n");
    fprintf(out, "};\n\n");
}

/*============================================================================
 * Main Generation Functions
 *============================================================================*/

int moc_generate_header(moc_ctx_t *ctx, FILE *out) {
    if (!out) out = stdout;

    /* Generate base name for file */
    char base_name[256] = "tools_gen";
    if (ctx->output_base) {
        const char *name = get_basename(ctx->output_base);
        strncpy(base_name, name, sizeof(base_name) - 1);
        base_name[sizeof(base_name) - 1] = '\0';
    }

    char guard_name[256];
    to_upper_underscore(base_name, guard_name, sizeof(guard_name));

    /* Write header start */
    fprintf(out, HEADER_TEMPLATE_START, base_name, guard_name, guard_name);

    /* Write tool declarations */
    for (int i = 0; i < ctx->tool_count; i++) {
        fprintf(out, "extern const ac_tool_t TOOL_%s;\n", ctx->tools[i].name);
    }

    /* Write all tools array declaration */
    fprintf(out, "%s", HEADER_TEMPLATE_ALL_TOOLS);

    /* Write header end */
    fprintf(out, HEADER_TEMPLATE_END, guard_name);

    return 0;
}

int moc_generate_source(moc_ctx_t *ctx, FILE *out) {
    if (!out) out = stdout;

    /* Generate base name for file */
    char base_name[256] = "tools_gen";
    if (ctx->output_base) {
        const char *name = get_basename(ctx->output_base);
        strncpy(base_name, name, sizeof(base_name) - 1);
        base_name[sizeof(base_name) - 1] = '\0';
    }

    /* Get input file base name */
    const char *input_basename = get_basename(ctx->input_file);

    /* Write source start */
    fprintf(out, SOURCE_TEMPLATE_START, base_name, base_name, input_basename);

    /* Generate description and parameters schema for each tool */
    fprintf(out, "/*============================================================================\n");
    fprintf(out, " * Tool Metadata\n");
    fprintf(out, " *============================================================================*/\n\n");
    
    for (int i = 0; i < ctx->tool_count; i++) {
        generate_description(out, &ctx->tools[i]);
        generate_parameters_schema(out, &ctx->tools[i]);
    }

    /* Write wrappers section header */
    fprintf(out, "/*============================================================================\n");
    fprintf(out, " * Wrapper Functions\n");
    fprintf(out, " *============================================================================*/\n\n");

    /* Generate wrapper functions */
    for (int i = 0; i < ctx->tool_count; i++) {
        generate_wrapper(out, &ctx->tools[i]);
    }

    /* Generate tool definitions */
    fprintf(out, "/*============================================================================\n");
    fprintf(out, " * Tool Definitions\n");
    fprintf(out, " *============================================================================*/\n\n");

    for (int i = 0; i < ctx->tool_count; i++) {
        generate_tool_definition(out, &ctx->tools[i]);
    }

    /* Generate ALL_TOOLS array */
    fprintf(out, "/*============================================================================\n");
    fprintf(out, " * All Tools Array\n");
    fprintf(out, " *============================================================================*/\n\n");

    fprintf(out, "const ac_tool_t *ALL_TOOLS[] = {\n");
    for (int i = 0; i < ctx->tool_count; i++) {
        fprintf(out, "    &TOOL_%s,\n", ctx->tools[i].name);
    }
    fprintf(out, "    NULL  /* Sentinel */\n");
    fprintf(out, "};\n\n");

    fprintf(out, "const size_t ALL_TOOLS_COUNT = %d;\n", ctx->tool_count);

    return 0;
}

int moc_generate(moc_ctx_t *ctx) {
    if (ctx->tool_count == 0) {
        fprintf(stderr, "Warning: No tools found to generate\n");
        return 0;
    }

    if (!ctx->output_base) {
        /* Output to stdout */
        fprintf(stdout, "/* ===== GENERATED HEADER ===== */\n\n");
        moc_generate_header(ctx, stdout);
        fprintf(stdout, "\n/* ===== GENERATED SOURCE ===== */\n\n");
        moc_generate_source(ctx, stdout);
        return 0;
    }

    /* Generate header file */
    char header_path[512];
    snprintf(header_path, sizeof(header_path), "%s.h", ctx->output_base);

    FILE *header_file = fopen(header_path, "w");
    if (!header_file) {
        fprintf(stderr, "Error: Failed to open %s for writing\n", header_path);
        return -1;
    }

    if (moc_generate_header(ctx, header_file) != 0) {
        fclose(header_file);
        return -1;
    }
    fclose(header_file);

    if (ctx->verbose) {
        printf("Generated: %s\n", header_path);
    }

    /* Generate source file */
    char source_path[512];
    snprintf(source_path, sizeof(source_path), "%s.c", ctx->output_base);

    FILE *source_file = fopen(source_path, "w");
    if (!source_file) {
        fprintf(stderr, "Error: Failed to open %s for writing\n", source_path);
        return -1;
    }

    if (moc_generate_source(ctx, source_file) != 0) {
        fclose(source_file);
        return -1;
    }
    fclose(source_file);

    if (ctx->verbose) {
        printf("Generated: %s\n", source_path);
    }

    return 0;
}
